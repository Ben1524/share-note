





# 算法模板

- [算法模板](#算法模板)
  - [二分](#二分)
  - [高精度](#高精度)
    - [高精度加法](#高精度加法)
    - [高精度减法](#高精度减法)
    - [高精度乘低精度](#高精度乘低精度)
    - [高精度乘高精度](#高精度乘高精度)
    - [高精度除以低精度](#高精度除以低精度)
    - [高精度除以高精度](#高精度除以高精度)
  - [快速幂](#快速幂)
  - [lowbit 运算](#lowbit-运算)
  - [快速排序](#快速排序)
  - [归并排序](#归并排序)
  - [离散化](#离散化)
  - [单调栈](#单调栈)
  - [单调队列](#单调队列)
  - [Trie 树](#trie-树)
  - [邻接表模板](#邻接表模板)
  - [最大公约数](#最大公约数)
    - [扩展欧几里得算法](#扩展欧几里得算法)
  - [并查集](#并查集)
  - [树状数组](#树状数组)
  - [线段树](#线段树)
    - [支持区间修改的线段树（延迟标记）](#支持区间修改的线段树延迟标记)
  - [质数筛选](#质数筛选)
  - [拓扑排序](#拓扑排序)
  - [Treap](#treap)
  - [最短路](#最短路)
    - [Dijkstra](#dijkstra)
    - [Bellman-Ford & SPFA](#bellman-ford--spfa)
    - [Floyd](#floyd)
  - [最小生成树](#最小生成树)
    - [Prim](#prim)
    - [Kruskal](#kruskal)
  - [二分图](#二分图)
    - [染色法判定二分图](#染色法判定二分图)
    - [求二分图的最大匹配](#求二分图的最大匹配)
  - [KMP 算法](#kmp-算法)
  - [字符串哈希](#字符串哈希)
  - [Manacher 求最长回文子串](#manacher-求最长回文子串)
  - 矩阵乘法
  - dfs

## 二分

始终要记住的一点是，如果新边界出现了 `mid - 1`，就需要在开始将 `mid` 赋值为 `(l + r + 1) >> 1`，多一个 `+ 1`。

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

具体例子：

```cpp
// 查找单调递增序列中 >= x 的最小一个数
while (l < r) {
    int mid = (l + r) >> 1;
    if (a[mid] >= x)
        r = mid;
    else
        l = mid + 1;
}
// 查找单调递增序列中 <= x 的最大一个数
while (l < r) {
    int mid = (l + r + 1) >> 1;
    if (a[mid] <= x)
        l = mid;
    else
        r = mid - 1;
}
```

## 高精度

```cpp
// 通用构造函数
for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
// 通用输出函数
void out(const vector<int> &A) {
    for (int i = A.size() - 1; i >= 0; i--) {
        cout << A[i];
    }
}
// 通用比较函数
// A < B, A > 0, B > 0
bool cmp(vector<int> &A, vector<int> &B) {
    if (A.size() != B.size()) {
        return A.size() < B.size();
    }
    for (int i = A.size() - 1; i >= 0; i--) {
        if (A[i] != B[i]) return A[i] < B[i];
    }
    return false;
}
```

### 高精度加法

模板题 AcWing 791. 高精度加法

```cpp
// O(n)
// C = A + B, A >= 0, B >= 0
vector<int> add(const vector<int> &A, const vector<int> &B) {
    if (A.size() < B.size()) return add(B, A);
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i++) {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}
```

### 高精度减法

模板题 AcWing 792. 高精度减法

```cpp
// O(n)
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(const vector<int> &A, const vector<int> &B) {
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i++) {
        // 如果借过位，需要减去 t（t 是借位数量）
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        // < 0  表示从高位借了一位出来了，所以 t = 1
        if (t < 0)
            t = 1;
        else
            t = 0;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 高精度乘低精度

模板题 AcWing 793. 高精度乘法

```cpp
// O(n)
// C = A * b, A >= 0, b > 0
vector<int> mul(const vector<int> &A, int b) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i++) {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t = t / 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 高精度乘高精度

```cpp
// O(nm)
// C = A * B, A >= 0, B >= 0
vector<int> mul(const vector<int> &A, const vector<int> &B) {
    vector<int> C(A.size() + B.size());
    for (int i = 0; i < A.size(); i++) {
        for (int j = 0; j < B.size(); j++) {
            C[i + j] += A[i] * B[j];
        }
    }
    int t = 0;
    for (int i = 0; i < C.size(); i++) {
        t += C[i];
        C[i] = t % 10;
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 高精度除以低精度

模板题 AcWing 794. 高精度除法

```cpp
// O(n)
// A / b = C ... r, A >= 0, b > 0
vector<int> div(const vector<int>& A, int b, int& r) {
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i--) {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r = r % b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 高精度除以高精度

```cpp
// O((n-m)*n)
pair<vector<int>, vector<int>> div(vector<int> A, const vector<int> &B) {
    vector<int> C, R;
    int n = A.size(), m = B.size(), d = n - m;
    C.resize(d + 1, 0);
    // 枚举补 0 的个数
    for (int len = d; len >= 0; len--) {
        vector<int> Bp(len, 0);
        for (int x : B) Bp.push_back(x);

        // A >= Bp
        while (!cmp(A, Bp)) {
            C[len] += 1;
            A = sub(A, Bp);
        }
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    R = A;
    return make_pair(C, R);
}
```

## 快速幂

- AcWing 89

```cpp
// 注意：底数可以取模，但是指数不能取模
// 模的性质：先模后乘（加）等于先乘（加）后模
int qpow(int a, int b, int p) {
    int ans = 1 % p;
    while (b) {
        if (b & 1) ans = 1ll * ans * a % p;
        a = 1ll * a * a % p;
        b >>= 1;
    }
    return ans;
}

LL qpow(LL a, LL b, LL p) {
    LL ans = 1ll % p;
    while (b) {
        if (b & 1) ans = 1ll * ans * a % p;
        a = 1ll * a * a % p;
        b >>= 1;
    }
    return ans;
}
```

## lowbit 运算

lowbit 运算返回的数是二进制表示下，原来数的最低位的 1 及后边所有的 0 组成的新的数。

```cpp
lowbit(1010_2) = lowbit(10_2)

lowbit(n) = n & (~n + 1) = n & -n

~n == -1 - n => ~n + 1 == -n

// 预计算 H[2^k] = k，Hash 替代 log 运算
for (int i = 0; i <= 20; i++) H[1 << i] = i;
// 找出整数 n 的二进制表示下所有是 1 的位
while (n > 0) {
    cout << H[n & -n] << " ";
    n -= n & -n;
}
cout << endl;
// 将区间 [1, n] 分为 O(log n) 个小区间，每个区间长度都是当前值的 lowbit
while (x > 0) {
    cout << (x - (x & -x) + 1) << ", "<< x << endl;
    x -= x & -x;
}
```

## 快速排序

```cpp
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j) {
        do i++;
        while (q[i] < x);
        do j--;
        while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```

## 归并排序

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = (l + r) >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

## 离散化

如果之后还需要进行查询，可以映射成有序数组。如果之后无需查询，直接映射成无序数组就可以了。

```cpp
// 离散化
void discrete() {
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++) {
        // 也可用 STL 的 unique 函数
        if (i == 1 || a[i] != a[i - 1])
            b[++m] = a[i];
    }
}
// 查询 x 映射为哪个 1-m 之间的整数
int query(int x) {
    return lower_bound(b + 1, b + m + 1, x) - b;
}

// ----------

// 也可使用 map，但是一般会比数组慢一些
unordered_map<int, int> mp;
void discrete() {
    for (int i = 1; i <=n; i++) {
        if (!mp.count(a[i]))
            mp[a[i]] = ++m;
    }
}
int query(int x) {
    return mp[x];
}
```

## 单调栈

```cpp
int lft[N], rht[N], stk[N], tt;
// 哨兵
h[0] = -1, h[n + 1] = -1;
tt = 0;
stk[++tt] = 0;
for (int i = 1; i <= n; i++) {
    while (h[stk[tt]] >= h[i]) tt--;
    lft[i] = stk[tt];
    stk[++tt] = i;
}
tt = 0;
stk[++tt] = n + 1;
for (int i = n; i >= 1; i--) {
    while (h[stk[tt]] >= h[i]) tt--;
    rht[i] = stk[tt];
    stk[++tt] = i;
}
```

- 直方图中的最大矩形
- 城市游戏
- 最大面积
- LeetCode 795. Number of Subarrays with Bounded Maximum
- LeetCode 1944. Number of Visible People in a Queue (套路比较深的单调栈)

## 单调队列

```cpp
for (int i = 1; i <= n; i++) {
    cin >> a, sum += a;
    // 队首一直出队直到满足 <=m 条件
    while (!dq.empty() && (i - dq.front().second > m)) {
        dq.pop_front();
    }
    if (dq.empty()) {
        ans = max(ans, sum);
    } else {
        ans = max(ans, sum - dq.front().first);
        // 不断删除队尾的不会优于当前 i 的左端点
        while (!dq.empty() && dq.back().first >= sum) dq.pop_back();
    }
    dq.emplace_back(sum, i);
}
```

- 最大子序和

## Trie 树

- AcWing 142 - 144, 1414

```cpp
// 在 Trie 树中，边表示一个字符，节点表示一个前缀，叶子节点表示一个字符串，cnt 用来计数叶子节点表示的字符串出现的次数
// N 为字符串总长度，26 表示字符可能取值范围大小（对于小写字符串为 26，对于二进制数为 2）
// trie[p][ch] = 0 表示叶子节点，为了语义上的一致性，取 p = 1 作为根节点，初始情况不插入任何字符串，就已经有一个节点了
// 也可以将 p = 0 作为根节点，++tot 改为 tot++ 即可
int trie[N][26], tot = 1, cnt[N], n, m;
void insert(string s) {
    int len = s.length(), p = 1;
    for (int k = 0; k < len; k++) {
        int ch = s[k] - 'a';
        if (trie[p][ch] == 0) trie[p][ch] = ++tot;
        p = trie[p][ch];
    }
    cnt[p]++;
}
int search(string t) {
    int len = t.length(), p = 1, ans = 0;
    for (int k = 0; k < len; k++) {
        p = trie[p][t[k] - 'a'];
        if (p == 0) return ans;
        ans += cnt[p];
    }
    return ans;
}

// 另一种在每个节点上都记录 cnt 的写法，支持 insert(a, -1) 删除操作
int trie[N][2], tot = 1, cnt[N];
void insert(int a, int v) {
    int p = 1;
    for (int i = 30; i >= 0; i--) {
        int j = a >> i & 1;
        if (trie[p][j] == 0) {
            trie[p][j] = ++tot;
        }
        p = trie[p][j];
        cnt[p] += v;
    }
}

int query(int a) {
    int ans = 0, p = 1;
    for (int i = 30; i >= 0; i--) {
        int j = a >> i & 1;
        if (cnt[trie[p][!j]]) {
            p = trie[p][!j];
            ans |= 1 << i;
        } else {
            p = trie[p][j];
        }
    }
    return ans;
}
```

## 邻接表模板

邻接表最简单的方法是直接用 `vector` 存储，但是用数组存储速度更快，也有一些优点（快速找到反向边）。这里采用的是蓝书的方法，y 总的方法于此略不同，参考[我的分享](https://www.acwing.com/blog/content/4689/)。

- AcWing 257

```cpp
// N, M 分别表示点数和边数，注意如果是无向图的话 M 一定要乘 2，否则会数组越界

// head[x] = m 表示点 x 的邻接表的表头是编号为 m 的边
// ver[m] 表示编号为 m 的边的终点
// edge[m] 表示编号为 m 的边的权值
int head[N], ver[M], edge[M], Next[M], tot;

// 加入有向边 (x, y)，权值为 z
void add(int x, int y, int z) {
    // 真实数据
    ver[++tot] = y, edge[tot] = z;
    // 在表头 x 处插入
    Next[tot] = head[x], head[x] = tot;
}

// 访问从 x 出发的所有边
for (int i = head[x]; i; i = Next[i]) {
    int y = ver[i], z = edge[i];
    // 找到了一条有向边 (x, y)，权值为 z
}

// 一般来说，memset 初始化就够了
memset(head, 0, sizeof head), tot = 0;

// 多测试用例时，初始化使用循环更好，例如: AcWing 3696
tot = 0;
for (int i = 1; i <= n; i++) {
    head[i] = 0;
    deg[i] = 0;
}
// Next 不需要初始化也可以的，因为每次 add 的时候会对用到的 Next 的改变都是基于 head 的
for (int i = 1; i <= m; i++) {
    Next[i] = 0;
}
```

## 最大公约数

```cpp
// 欧几里得算法
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```

另外，最小公倍数 lcm(a, b) = a * b / gcd(a, b)。

### 扩展欧几里得算法

求 ax + by = gcd(a, b) 的一对整数解 (x, y)。一般形式 ax + by = c 有解，当且仅当 d | c（d 是 a 和 b 的最大公约数）。

```cpp
int extgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int d = extgcd(b, a % b, x, y);
    int z = x;
    x = y;
    y = z - a / b * y;
    return d;
}
```

## 并查集

```cpp
// sz 表示节点的秩，这里定义为节点的元素个数
int fa[N], sz[N], n;
void init() {
    // 初始化
    for (int i = 0; i <= n; i++) {
        fa[i] = i;
        sz[i] = 1;
    }
}
// Get 操作，使用「路径压缩」+「按秩合并」，时间复杂度为反阿克曼函数，可以认为是常数
int get(int x) {
    if (x == fa[x]) return x;
    // 路径压缩，fa 直接赋值为代表元素
    return fa[x] = get(fa[x]);
}
// Merge 操作，同上，可以认为时间复杂度为常数
void merge(int x, int y) {
    int fx = get(x), fy = get(y);
    if (fx == fy) return;
    if (sz[fx] < sz[fy]) {
        fa[fx] = fy;
        sz[fy] += sz[fx];
    } else {
        fa[fy] = fx;
        sz[fx] += sz[fy];
    }
}

// 一定记得初始化并查集
init();
```

另外还有「边带权」和「拓展域」的并查集，在原有并查集的基础上维护一些具有传递关系的属性。

## 树状数组

RMQ 常用算法，参见蓝书 0x42。`c[x]` 保存序列 a 的区间 `[x - lowbit(x) + 1, x]` 中所有数的和。`c[x]` 的父节点为 `c[x + lowbit(x)]`

支持「单点增加」和「区间查询」，结合差分可以支持「区间增加」。

```cpp
// 查询前缀和：查询序列 a 第 1~x 个数的和
int ask(int x) {
    int ans = 0;
    for (; x; x -= x & -x) ans += c[x];
    return ans;
}
// 单点增加：给序列中的一个数 a[x] 加上 y
// 算法：自下而上每个节点都要增加 y
void add(int x, int y) {
    for (; x <= n; x += x & -x) c[x] += y;
}
```

```cpp
// https://www.cnblogs.com/qdscwyy/p/9759220.html

int lowbit(int x) {
    return x & (-x);
}
void updata(int x, int k) {
    while (x <= n) {
        h[x] = k;
        int low = lowbit(x);
        for (int i = 1; i < low; i <<= 1)
            h[x] = max(h[x], h[x - i]);
        x += lowbit(x);
    }
}
// 区间查询 [x, y] 的 max
int query(int x, int y) {
    int ans = 0;
    while (y >= x)
    {
        ans = max(a[y], ans), y -= 1;
        for (; y-lowbit(y) >= x; y -= lowbit(y))
            ans = max(h[y], ans);
    }
    return ans;
}
```

## 线段树

RMQ 常用算法，树状数组基于区间划分，线段树则是基于分治。

```cpp
struct SegmentTree {
    int l, r;
    int dat;
} tree[N * 4];

// 线段树的建树，时间复杂度：O(N)
// p 表示节点编号，[l, r] 表示节点所代表的区间
void build(int p, int l, int r) {
    tree[p].l = l, tree[p].r = r;
    // 叶节点，表示单个元素
    if (l == r) {
        tree[p].dat = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    // 左子节点：编号为 2*p，代表区间 [l, mid]
    build(2 * p, l, mid);
    // 右子节点：编号为 2*p+1，代表区间 [mid+1, r]
    build(2 * p + 1, mid + 1, r);
    // 从下往上合并更新信息
    tree[p].dat = max(tree[2 * p].dat, tree[2 * p + 1].dat);
}


// 线段树的单点修改，时间复杂度：O(log N)
// 将 a[x] 的值修改为 v
void change(int p, int x, int v) {
    // 找到叶节点
    if (tree[p].l == tree[p].r) {
        tree[p].dat = v;
        return;
    }
    int mid = (tree[p].l + tree[p].r) >> 1;
    // x 属于左半区间
    if (x <= mid) change(2 * p, x, v);
    // x 属于右半区间
    else
        change(2 * p + 1, x, v);
    // 从下往上合并更新信息
    tree[p].dat = max(tree[2 * p].dat, tree[2 * p + 1].dat);
}

// 线段树的区间查询，时间复杂度：O(log N)
// 查询序列 a 在区间 [l, r] 上的最大值
int ask(int p, int l, int r) {
    // 查询区间 [l, r] 完全包含节点 p 所代表的的区间
    if (l <= tree[p].l && r >= tree[p].r) return tree[p].dat;
    int mid = (tree[p].l + tree[p].r) >> 1;
    // 负无穷大
    int val = -(1 << 30);
    // 左子节点 [tree[p].l, mid] 与查询 [l, r] 有重合
    if (l <= mid) val = max(val, ask(2 * p, l, r));
    // 右子节点 [mid+1, tree[p].r] 与查询 [l, r] 有重合
    if (r >= mid + 1) val = max(val, ask(2 * p + 1, l, r));
    return val;
}

// 调用入口
build(1, 1, n);
change(1, x, v);
```

### 支持区间修改的线段树（延迟标记）

区间修改的时间复杂度可以通过延迟标记从 O(N) 降为 O(log N)。

```cpp
// 注意：有延迟标记的节点，本身已经完成了数据更新，只是没有传递给子节点
struct SegmentTree {
    int l, r;
    long long dat, lazy;
#define l(x) tree[x].l
#define r(x) tree[x].r
#define dat(x) tree[x].dat
#define lazy(x) tree[x].lazy
} tree[N * 4];
int a[N];

void build(int p, int l, int r) {
    l(p) = l, r(p) = r;
    if (l == r) {
        dat(p) = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(2 * p, l, mid);
    build(2 * p + 1, mid + 1, r);
    dat(p) = dat(2 * p) + dat(2 * p + 1);
}
void spread(int p) {
    // 节点 p 有延迟标记的话
    if (lazy(p)) {
        // 更新左子节点信息，延迟值 * 区间长度等于节点的增加量
        dat(2 * p) += lazy(p) * (r(2 * p) - l(2 * p) + 1);
        // 更新右子节点信息
        dat(2 * p + 1) += lazy(p) * (r(2 * p + 1) - l(2 * p + 1) + 1);
        // 给左子节点打延迟标记
        lazy(2 * p) += lazy(p);
        // 给右子节点打延迟标记
        lazy(2 * p + 1) += lazy(p);
        // 清除 p 的标记
        lazy(p) = 0;
    }
}

void change(int p, int l, int r, int d) {
    // 完全覆盖
    if (l <= l(p) && r >= r(p)) {
        // 更新节点信息，每个节点增加量 d * 区间长度 = 节点增加量
        dat(p) += (long long)d * (r(p) - l(p) + 1);
        // 给节点打延迟标记
        lazy(p) += d;
        return;
    }
    // 因为即将访问下面的节点了，必须先下传延迟标记
    spread(p);
    int mid = (l(p) + r(p)) >> 1;
    // 和左子节点有相交部分
    if (l <= mid) change(2 * p, l, r, d);
    // 和右子节点有相交部分
    if (r >= mid + 1) change(2 * p + 1, l, r, d);
    dat(p) = dat(2 * p) + dat(2 * p + 1);
}

long long ask(int p, int l, int r) {
    if (l <= l(p) && r >= r(p)) return dat(p);
    // 因为即将访问下面的节点了，必须先下传延迟标记
    spread(p);
    int mid = (l + r) >> 1;
    long long val = 0;
    if (l <= mid) val += ask(2 * p, l, r);
    if (r >= mid + 1) val += ask(2 * p + 1, l, r);
    return val;
}
```

- AcWing 243

## 质数筛选

```cpp
// Eratosthenes 筛法，时间复杂度 O(\sum_{质数 p <= n} n/p) = O(n log log n)
void primes(int n) {
    // 合数标记
    memset(v, 0, sizeof v);
    for (int i = 2; i <= n; i++) {
        if (v[i]) continue;
        cout << i << endl;
        for (int j = i; j <= n/i; j++) v[i*j] = 1;
    }
}
```

```cpp
int primes[N], cnt;
bool st[N];
// 线性筛法
// 每个数只会被自己的最小质因子筛掉，时间复杂度为 O(n)
void get_primes_l(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        // j < cnt 没有必要，因为 i 是合数的时候，枚举到最小质因子一定会 break
        // 如果 i 是质数 primes[j] == i 的时候也会停止循环
        for (int j = 0; primes[j] <= n / i; j++) {
            // primes[j] 是 primes[j] * i 的最小质因子
            st[primes[j] * i] = true;
            // primes[j] 一定是 i 的最小质因子（因为 j 是从小到大枚举的）
            // 之所以要 break 是因为后面的 primes[j+1] 不再是 primes[j+1] * i 的最小质因子了，而是 primes[j]，因为 i % primes[j] == 0
            if (i % primes[j] == 0) break;
        }
    }
}
```

## 拓扑排序

```cpp
// 拓扑排序模板
void topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (deg[i] == 0) q.push(i);
    }
    while (q.size()) {
        int x = q.front();
        q.pop();
        a[++cnt] = x;
        for (int i = head[x]; i; i = Next[i]) {
            int y = ver[i];
            if (--deg[y] == 0) q.push(y);
        }
    }
}
```

## Treap

```cpp
// 数组模拟链表
struct Treap {
    // 左右子节点在数组中的下标
    int l, r;
    // 节点的关键码、权值
    int val, dat;
    // 副本数、子树大小
    int cnt, size;
} a[N];
int tot, root, n, INF = 0x7fffffff;

int New(int val) {
    a[++tot].val = val;
    // 随机初始化权值
    a[tot].dat = rand();
    a[tot].cnt = a[tot].size = 1;
    return tot;
}

// 类似线段树自下往上的更新过程
void Update(int p) {
    a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].cnt;
}

void Build() {
    // 为避免越界，减少边界情况特殊判断，加入哨兵
    New(-INF), New(INF);
    root = 1, a[1].r = 2;
    Update(root);
}

// 把 p 的左子节点绕着 p 向右旋转，注意 p 是引用
void zig(int &p) {
    int q = a[p].l;
    a[p].l = a[q].r, a[q].r = p, p = q;
    Update(a[p].r), Update(p);
}
// 把 p 的右子节点绕着 p 向左旋转，注意 p 是引用
void zag(int &p) {
    int q = a[p].r;
    a[p].r = a[q].l, a[q].l = p, p = q;
    Update(a[p].l), Update(p);
}

// 注意 p 是引用
void Insert(int &p, int val) {
    if (p == 0) {
        p = New(val);
        return;
    }
    // 如果之前已经有相同关键码的节点，只需要 cnt++ 即可
    if (val == a[p].val) {
        a[p].cnt++, Update(p);
        return;
    }
    // 在左子树中插入
    if (val < a[p].val) {
        Insert(a[p].l, val);
        // 不满足堆性质，右旋
        if (a[p].dat < a[a[p].l].dat) zig(p);
    }
    // 在右子树中插入
    else {
        Insert(a[p].r, val);
        // 不满足堆性质，左旋
        if (a[p].dat < a[a[p].r].dat) zag(p);
    }
    Update(p);
}

int GetPre(int val) {
    // a[1].val = -INF
    int ans = 1;
    int p = root;
    // 一直循环直到找到一个关键码为 val 的节点，找到之后会直接 break
    // 找不到也没关系，已经经过的节点中一定包含答案，ans 即为所求
    while (p) {
        if (val == a[p].val) {
            if (a[p].l > 0) {
                p = a[p].l;
                // 左子树一直往右走
                while (a[p].r > 0) p = a[p].r;
                ans = p;
            }
            // 检索成功之后会 break 掉
            break;
        }
        // 节点 p 是小于 val 的，并且相比 ans 离 val 更近，更新 ans
        if (a[p].val < val && a[p].val > a[ans].val) ans = p;
        // 根据 val 情况往左或者往右走
        p = val < a[p].val ? a[p].l : a[p].r;
    }
    return a[ans].val;
}

int GetNext(int val) {
    // a[2].val == INF
    int ans = 2;
    int p = root;
    while (p) {
        if (val == a[p].val) {
            if (a[p].r > 0) {
                p = a[p].r;
                // 右子树一直往左走
                while (a[p].l > 0) p = a[p].l;
                ans = p;
            }
            break;
        }
        if (a[p].val > val && a[p].val < a[ans].val) ans = p;
        p = val < a[p].val ? a[p].l : a[p].r;
    }
    return a[ans].val;
}
```

- AcWing 253

## 最短路

### Dijkstra

```cpp
// 朴素：O(N^2)，适用于 M 比较大，N 很小的情况
void dijkstra() {
    memset(d, 0x3f, sizeof d);
    d[1] = 0;
    // 重复 n - 1 次
    for (int i = 1; i < n; i++) {
        int x = 0;
        // 找到未标记节点中 dist 最小的
        for (int j = 1; j <= n; j++) {
            if (!v[j] && (x == 0 || d[j] < d[x]))
                x = j;
        }
        v[x] = 1;
        // 用全局最小值点 x 更新其他节点
        for (int y = 1; y <= n; y++)
            d[y] = min(d[y], d[x] + a[x][y]);
    }
}
// 堆优化：O(M log N)，适用于 N 比较大的情况
void dijkstra() {
typedef pair<int, int> PII;
    priority_queue<PII, vector<PII>, greater<PII>> pq;
    memset(d, 0x3f, sizeof d);
    d[1] = 0;
    pq.push({0, 1});
    while (pq.size()) {
        // 取出堆顶
        int x = pq.top().second;
        pq.pop();
        if (v[x]) continue;
        v[x] = 1;
        // 扫描所有出边
        for (int i = head[x]; i; i = Next[i]) {
            int y = ver[i], z = edge[i];
            if (d[y] > d[x] + z) {
                d[y] = d[x] + z;
                pq.push({d[y], y});
            }
        }
    }
}
```

### Bellman-Ford & SPFA

```cpp
// Bellman-Ford 算法，时间复杂度 O(NM)
// 在求解有边数限制的最短路问题时，一般选择 Bellman-Ford 算法更好，最外层循环次数就是边数限制
// 在 Bellman-Ford 算法中，最后 d[n] 虽然是无穷大，但是中间可能被一些负权值更新过，略小于 0x3f3f3f3f，其实也可以在 relax 的是时候做一个特判，无穷大的边不 relax 就行
// 最后无穷大的判断用 > 0x3f3f3f3f / 2
struct P {
    int x, y, z;
} e[M];
memset(d, 0x3f, sizeof d);
d[1] = 0;
for (int i = 1; i <= k; i++) {
    memcpy(last, d, sizeof d);

    for (int j = 1; j <= m; j++) {
        // 从上次的 last 距离转移，而不是这次的进行转移，否则边数多于 i 了
        d[e[j].y] = min(d[e[j].y], last[e[j].x] + e[j].z);
    }
}
// SPFA 求最短路，在随机图上时间复杂度为 O(km)，其中 k 是较小的常数，在特殊构造的图上可能退化为 O(nm)
void spfa() {
    queue<int> q;
    memset(d, 0x3f, sizeof d);
    d[1] = 0, v[1] = 1;
    q.push(1);
    while (q.size()) {
        // 取出队头
        int x = q.front();
        q.pop();
        v[x] = 0;
        // 扫描所有出边
        for (int i = head[x]; i; i = Next[i]) {
            int y = ver[i], z = edge[i];
            if (d[y] > d[x] + z) {
                // 更新，把新的二元组插入堆
                d[y] = d[x] + z;
                if (!v[y]) q.push(y), v[y] = 1;
            }
        }
    }
}
// SPFA 判断负环
bool spfa() {
    // d 数组无需初始化，因为我们最终需要求的不是真正的距离

    // 因为要求所有可能的负环，所以所有点都当做起点加进去
    for (int i = 1; i <= n; i++) {
        v[i] = 1;
        q.push(i);
    }

    while (q.size()) {
        // 取出队头
        int x = q.front();
        q.pop();
        v[x] = 0;
        // 扫描所有出边
        for (int i = head[x]; i; i = Next[i]) {
            int y = ver[i], z = edge[i];
            if (d[y] > d[x] + z) {
                // 更新，把新的二元组插入堆
                d[y] = d[x] + z;
                cnt[y] = cnt[x] + 1;
                if (cnt[y] >= n) return true;
                if (!v[y]) q.push(y), v[y] = 1;
            }
        }
    }
}
```

### Floyd

```cpp
// 跟 Bellman-Ford 算法一样，最后 d[n] 虽然是无穷大，但是中间可能被一些负权值更新过，略小于 0x3f3f3f3f，其实也可以在 relax 的是时候做一个特判，无穷大的边不 relax 就行
// 最后无穷大的判断用 > 0x3f3f3f3f / 2
memset(d, 0x3f, sizeof d);
for (int i = 1; i <= n; i++) d[i][i] = 0;
for (int i = 1; i <= m; i++) {
    cin >> x >> y >> z;
    d[x][y] = min(d[x][y], z);
}
// floyd 求任意两点间最短路径
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
        }
    }
}
```

## 最小生成树

### Prim

```cpp
// Prim 采用加点的思想，时间复杂度为 O(N^2)，堆优化版为 O(M log N)，适用于稠密图，一般直接用朴素版即可
// 因为在点少的时候使用，如果点多的话，直接用 Kruskal 就好了，而且 Kruskal 好写很多
void prim() {
    memset(d, 0x3f, sizeof d);
    d[1] = 0;
    for (int i = 1; i < n; i++) {
        int x = 0;
        for (int j = 1; j <= n; j++) {
            if (!v[j] && (x == 0 || d[j] < d[x]))
                x = j;
        }
        v[x] = 1;
        for (int y = 1; y <= n; y++) {
            // 注意这里是和 Dijkstra 的区别所在，求的是到集合的距离，不需要加 d[x] 了
            // 这里可以求出生成树中 y 的前驱结点是谁
            if (!v[y]) d[y] = min(d[y], a[x][y]);
        }
    }
}
```

### Kruskal

```cpp
// Kruskal 是加边的算法，用到了并查集维护生成森林的所有点，时间复杂度为 O(M log M)
struct P {
    int x, y, z;
    bool operator<(const P& b) {
        return z < b.z;
    }
} edge[M];
sort(edge + 1, edge + m + 1);
// 并查集初始化
for (int i = 1; i <= n; i++) fa[i] = i;
// 求最小生成树
for (int i = 1; i <= m; i++) {
    int x = get(edge[i].x);
    int y = get(edge[i].y);
    if (x == y) continue;
    fa[x] = y;
    ans += edge[i].z;
}
// 可以逐一判断是否属于一个集合
// y 总则是看看上面的循环是不是 merge 了 n-1 次
for (int i = 2; i <= n; i++) {
    if (get(i) != get(1)) {
        puts("impossible");
        return 0;
    }
}
```

## 二分图

### 染色法判定二分图

```cpp
bool dfs(int x, int color) {
    v[x] = color;
    for (int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if (!v[y]) {
            if (!dfs(y, 3 - color)) return false;
        } else {
            if (v[y] == color) return false;
        }
    }
    return true;
}
bool isBipartite() {
    for (int i = 1; i <= n; i++) {
        if (!v[i]) {
            if (!dfs(i, 1)) return false;
        }
    }
    return true;
}
```

### 求二分图的最大匹配

```cpp
bool dfs(int x) {
    for (int i = head[x], y; i; i = Next[i]) {
        if (!v[y = ver[i]]) {
            v[y] = 1;
            // 如果 y 正好没有男朋友；或者 y 有男朋友，但是 y 的男朋友 match[y] 可以换一个妹子的话；那么就把 y 的男朋友设置为 x
            if (!match[y] || dfs(match[y])) {
                match[y] = x;
                return true;
            }
        }
    }
    return false;
}
for (int i = 1; i <= n1; i++) {
    memset(v, 0, sizeof v);
    if (dfs(i)) ans++;
}
```

## KMP 算法

```cpp
// 求 A 在 B 中的各次出现位置
void calcNext() {
    // KMP 模板，Next[i] 表示「A 中以 i 结尾的非前缀子串」与「A 的前缀」能够匹配的最大长度
    Next[1] = 0;
    // j 的值在 while 循环中不断减小，j = Next[j] 的执行次数不会超过每层 for 循环开始时 j 的值与 while 循环结束时 j 的值之差
    // 每层 for 循环，j 的值至多增加 1，j 始终非负，因此减小幅度总和不会超过增加幅度总和
    // j 的变化次数至多为 2(N +M)，算法时间复杂度为 O(N + M)
    for (int i = 2, j = 0; i <= n; i++) {
        while (j > 0 && a[i] != a[j + 1]) j = Next[j];
        if (a[i] == a[j + 1]) j++;
        Next[i] = j;
    }
}
for (int i = 1, j = 0; i <= m; i++) {
    while (j > 0 && (j == n || b[i] != a[j + 1])) j = Next[j];
    if (b[i] == a[j + 1]) j++;
    // f[i] 表示「B 中以 i 结尾的非前缀子串」与「A 的前缀」能够匹配的最大长度
    f[i] = j;
    if (j == n) {
        // A 在 B 中某次出现的起始下标
        printf("%d ", i - n);
    }
}
```

## 字符串哈希

```cpp
typedef unsigned long long ULL;
const int P = 131;
p[0] = 1;
int n = s.length();
for (int i = 1; i <= n; i++) {
    f[i] = f[i - 1] * P + (s[i - 1] - 'a' + 1);
    p[i] = P * p[i - 1];
}
ULL getHash(int l, int r) {
    return f[r] - f[l - 1] * p[r - l + 1];
}
if (getHash(l1, r1) == getHash(l2, r2)) {
    cout << "Yes" << endl;
} else {
    cout << "No" << endl;
}
```

## Manacher 求最长回文子串

注意，「子串」和「子序列」是不同的，「子串」是原字符串中连续的一段，「子序列」原字符串中选一些字符保持原来的顺序构成的新的串。

```cpp
// p[i]表示 Str 中以下标i为回文中心的最大回文半径。
// 如果我们得到了p[i]，那么p[i] - 1就是原串 S 以i为回文中心的最大回文长度
// rt表示已经计算过的回文串能达到的最远右边界的下一个位置,mid表示rt所对应的最左侧的回文中心
// rt=max(j+p[j]),j \in [1,i−1]
// mid + p[mid] == rt

int manacher() {
    n = strlen(s);
    str[0] = '!', str[1] = '#'; /* str[0]为哨兵 */
    for (int i = 0; i < n; i++) {
        str[i * 2 + 2] = s[i];
        str[i * 2 + 3] = '#';
    }
    m = n * 2 + 1;
    str[m + 1] = '@'; /* 哨兵 */

    int rt = 0, mid = 0;
    int res = 0;
    for (int i = 1; i <= m; i++) {
        p[i] = i < rt ? min(p[2 * mid - i], rt - i) : 1;
        while (str[i + p[i]] == str[i - p[i]]) p[i]++;
        if (i + p[i] > rt) {
            rt = i + p[i];
            mid = i;
        }
        res = max(res, p[i] - 1);
    }
    return res;
}
```

## 矩阵乘法

```c++
#include<iostream>
#include<vector>
using namespace std;

// 矩阵转置
void MatrixTranspose(const vector<vector<int>>&v1,vector<vector<int>>&v2)
{
    int rows = v1.size(), cols = v1[0].size();
    v2.resize(cols);
    for (int i = 0; i < cols; i++)
    {
        v2[i].resize(rows);
        for (int j = 0; j < rows; j++)
        {
            v2[i][j] = v1[j][i];
        }
    }
}

void MatrixMulte(const vector<vector<int>>&v1,const vector<vector<int>>&v2,vector<vector<int>>&v3)
{
    int row1=v1.size(),col1=v1[0].size();  // col1==row2
    int row2=v2.size(),col2=v2[0].size();
    v3.resize(row1); // 结果矩阵row1*col2;
    for(int i = 0; i < row1; i++)
    {
        v3[i].resize(col2);
        for(int j = 0; j < col2; j++)
        {
            v3[i][j] = 0;
            for(int k = 0; k < col1; k++) // v1第i行的每个元素与v2第j列的每个元素相乘
            {
                v3[i][j] += v1[i][k] * v2[k][j];
            }
        }
    }
}
int main()
{
    // 解除cin与stdin的同步
    ios::sync_with_stdio(false);
    // 解除cin与cout的绑定
    cin.tie(0);
    int n,d;
    cin>>n>>d;
    vector<vector<int>> Q,K,V;
    Q.resize(n);
    K.resize(n);
    V.resize(n);
    vector<int>W;
    W.resize(n);
    for(int i=0;i<n;i++)
    {
        Q[i].resize(d);  //提前分配后面当二维数组使用
        K[i].resize(d);
        V[i].resize(d);
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<d;j++)
        {
            cin>>Q[i][j];
        }
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<d;j++)
        {
            cin>>K[i][j];
        }
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<d;j++)
        {
            cin>>V[i][j];
        }
    }
    for(int i=0;i<n;i++)
    {
        cin>>W[i];
    }
    vector<vector<int>>K2;
    MatrixTranspose(K,K2);

    vector<vector<int>> temp;
    MatrixMulte(Q,K2,temp);
    for (int i = 0; i < n; i++)
    {
        for(int j = 0; j < temp[0].size(); j++)
        {
            temp[i][j]*=W[i];
        }
    }
    vector<vector<int>> result;
    MatrixMulte(temp,V,result);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < d; j++)
        {
            cout<<result[i][j];
            if(j!=d-1)
                cout<<" ";
        }
        if(i!=n-1)
        cout << endl;
    }
}
```



## 二分模板

```c++
int left=下界,right=上界+1,mid;
while(left<right)
{
    mid=left+(right - left)/2;
    if(条件满足)
        left = mid+1;
    else
        right = mid;
}
```

```c++
int left=下界,right=上界,mid;
while(left<=right)
{
    mid=left+(right - left)/2;
    if(条件满足)
        left = mid+1;
    else
        right = mid-1;
}
```

## 双指针

1. 首尾双指针

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        if(height.size() == 0||height.size() ==1)
            return 0;
        int left=0,right=height.size()-1; // 首尾边界
        int sum=0;
        while (left < right)
        {
            sum=max(sum,(min(height[right],height[left])*(right - left))); // 求容量
            if(height[left]<height[right]) // left边界指针收缩条件
            {
                left++;
            }
            else  // right边界指针收缩条件
            {
                right--;
            }
        }
        return sum;
    }
};
```

2. 快慢指针

   ```c++
   class Solution {
   public:
       int removeElement(vector<int>& nums, int val) 
       {
           int slow=0; // 慢指针视情况移动
           for(int fast=0;fast<nums.size();fast++) // 快指针无脑移动
           {
               if(nums[fast]^val) // 慢指针移动条件
                   nums[slow++]=nums[fast];
           }
           return slow;
       }
   };
   ```

   

## 树

1. DFS

```c++
    void DFS(TreeNode*root,int currentIndex,int currentSum,int targetSum) // currentIndex用于在不同岔路口获得不同的值
    {
        
        if(root== nullptr)
            return;
        path[currentIndex]=root->val; // 先更新路径再去判断,否则会导致末尾可能没有更新
        if(root->left== nullptr&&root -> right == nullptr&&targetSum==currentSum)
        {
            vector<int>temp;
            for(int i=0;i<currentIndex+1;i++)
            {
                temp.push_back(path[i]);
            }
            res.push_back(temp);
            return;
        }
        if(root->left!=nullptr) // 左右子树会分别重设currentIndex的
            DFS(root->left,currentIndex+1,currentSum+root->left->val,targetSum);
        if(root -> right != nullptr)
            DFS(root->right,currentIndex+1,currentSum+root -> right -> val,targetSum);
    }
```

```c++
ool dfs(TreeNode*left,TreeNode * right)
        {
            if(left== nullptr&&right== nullptr)
                return true;
            if(left== nullptr||right== nullptr)
                return false;
            if(left->val!=right->val)
                return false;
            return dfs(left->left,right->right)&&dfs(left->right,right -> left);
        }
```

> DFS强调的是从一种状态开始沿着状态变化到达边界的过程,只有到达边界才会去重新变换路径

2. BFS

   ```c++
   bool visited[300][300];
       int m,n;
       int dx[4]={-1,1,0,0};
       int dy[4]={0,0,-1,1};
   void bfs(int x,int y,vector<vector<char>>& grid)
       {
           queue<pair<int,int>> q;
           q.push(make_pair(x,y)); // 初始化
           visited[x][y]=1; // 访问
           while(!q.empty())
           {
               pair<int,int> p=q.front();
               q.pop();
               for(int i=0;i<4;i++)
               {
                   int nx=p.first+dx[i];
                   int ny=p.second+dy[i];
                   if(nx>=0&&nx<m&&ny>=0&&ny<n&&grid[nx][ny]=='1'&&!visited[nx][ny])// 不出界,未访问,条件满足
                   {
                       q.push(make_pair(nx,ny));
                       visited[nx][ny]=1;
                   }
               }
           }
       }
   ```

   

3. 并查集

```c++
// 初始化 map<int,int>m 当前元素,父亲结点
for(auto &i:nums)
{
    m.insert(make_pair(i,i));
}

// 查根并且重新序列化
int findRoot(int x)
{
    int a=x; // 记录当前值,x在下面更新为 该集合的根
    while(x!=m[x])
    {
        x=m[x];
    }
    while(a!=m[a]) // 路径压缩
    {
        int z=a;
        a=m[a]; // 迭代父亲
        m[z]=x;
    }
    return x;
}

void unionXY(int x,int y) // 把x合并到y
{
    int fx= findRoot(x);
    int fy= findRoot(y);
    if(fx!=fy)
        m[fx]=fy;
}
```

> 并查集维护多个无重复结点的树 ,通过并查集`可以快速查找多个序列之间的关系 用于处理不相交集合的合并与查询问题。`





# 回溯法

##把问题的解空间转化成了==图或者树的结构==表示，然后使用==深度优先搜索==策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。



1. 首先从根节点出发搜索解空间树或者图，当算法搜索至解空间树的某一节点时，先利用**剪枝函数**判断该节点是否可行 , 如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。
2. 剪枝函数包括两类：1. 使用约束函数，==剪去不满足约束条件的路径==；2.使用限界函数，剪去不能得到==最优解==的路径。

3.   回溯法的实现方法有两种：==递归和递推==（也称迭代）。一般来说，一个问题两种方法都可以实现，只是在算法效率和设计复杂度上有区别



####回溯算法模板

```c++
res  // 存储结果的全局数组 或者引用传递到dfs中
    
void dfs(已经做出的选择,当前要做的选择)
{
    if(条件满足)
        res.insert(路径) // 路径就是所有的选择都做完了
        return
     for(选择列表)
     {
         // 做出选择 注意剪枝
         // 从选择列表删除
         dfs(,+1)//下一步选择
         // 撤销选择
         // 恢复选择列表
     }
        
}
```













# 分而治之

# ---自底向上求解思想



算法框架

```c++
DivideAndConqueer(int n) // n为问题规模
{
    if(n<n0) // 达到子问题的规模
    {
        求解；
        返回子问题的解
    }
    分解子问题；//左 mid  mid+1 右
    合并；
    返回结果；  
}
```





##前言  

$数组的一些常用计算公式：$
$长度 n=right-left+1$
$下标 index=start+len-1$

数组分治的算法经常涉及**递归分割**，分割最重要的是基准也就是**子数组的长度**，递归算法的进行是在把数组分割成基准长度的子数组后开始向上执行，类似于**触碰到底然后反弹**的思想



##1.归并排序 

<img src="D:\好康的\image-20230102223544943.png" alt="image-20230102223544943" style="zoom:50%;" />













1.非递归写法

```c++
void Merge(int a[],int b[],int l,int m,int r) // 合并l-m，m+1-d的子数组，思路就是选择较小的放入b中
{
    int i=l,j=m+1,k=l; // k=l,不要初始化
    while((i<=m)&&(j<=r))
    {
        if(a[i]<a[j])
            b[k++]=a[i++];
        else
            b[k++]=a[j++];
    }
    while(i<=m)// 左子数组未遍历完, 这是小于等于号，因为提前退出，i或者j保存着下次要比较的元素的下标,否则就不执行循环
        b[k++]=a[i++];
    while(j<=r)
        b[k++]=a[j++];
}

void MerPass(int a[],int t[],int s,int n)
{
    int i=0;
    while (i<=n-2*s) // 合并长度为s且相邻的两个子数组到t中，i为子数组的起始下标，如果i==n-2*s，刚好合并了最后两个子数组
    {
        Merge(a,t,i,i+s-1,i+2*s-1); // 数组右边界的计算公式为：起始下标+长度-1
        i+=2*s;
    }
    // 循环退出说明i+2*s>n-2*s
    if(i+s<n) // i+s-1<n-1，i+2*s>n,即i+s<n，合并剩下的两个子数组,剩余的最后一个子数组长度小于s
        Merge(a,t,i,i+s-1,n-1);
    else
        while(i<=n-1) // i+s-1>=n-1，i+2*s>n,即i+s>=n，仅剩最后一个子数组并且长度小于s，合并剩下的最后一个子数组
        {
            t[i]=a[i];
            i++;
        }
}
void MeraSort(int a[],int n)
{
    auto *t=new int [n];
    int s=1; // 子数组的大小
    while(s<n)
    {
        MerPass(a,t,s,n); // 合并长度为s的子数组，放到t中
        s<<=1;
        MerPass(t,a,s,n);// 合并长度为s的子数组，放到a中，这里的a和t是交替使用的
        // 不会出现a中的元素还没合并但是t中的元素已经合并的情况，因为每次合并的子数组长度都是s，s是2的幂，所以每次合并的子数组都是相邻的
        // 也就是说，a中的元素都是在t中合并的，t中的元素都是在a中合并的
        // 每次循环执行都会将a中的元素合并到t中，t中的元素合并到a中
        s<<=1;
    }
    delete[] t;
}
```



2.递归写法

```c++
void Merge(int a[],int l,int m,int r) // 合并l->m，m+1->d的子数组
{
    int i = l, j = m + 1, k = 0;
    int *temp = new int[r - l + 1]; // 创建临时数组
    while (i <= m && j <= r)
    {
        if (a[i] <= a[j])
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }
    while (i <= m)
        temp[k++] = a[i++];
    while (j <= r)
        temp[k++] = a[j++];
  for (i = l, k = 0; i <= r; i++, k++) // 将临时数组的值复制到原数组
        a[i] = temp[k];
    delete[]temp;
}
void MergSort(int a[],int left,int right)
{
    if(left<right)
    {
        int mid=(left+right)/2;
        MergSort(a,left,mid);
        MergSort(a,mid+1,right);
        Merge(a,left,mid,right);
    }
    else
        return;
}
```

### 总结

递归与非递归的写法主要是在子数组长度（基准）上下文章，非递归初始化  ==s=1==，然后长度不断乘2合并相邻子数组，递归主要就是不断分割直至子数组长度到基准长度，然后反弹执行。

时间复杂度为 $O（nlogn）$



## 逆序对数和以及最少交换次数

对于一个乱序序列，如果它的逆序对数是 k，那么它最少需要交换 k 次才能变成一个有序序列。

这是因为每次交换一对逆序对就可以使逆序对数减少 1，因此最少需要交换 k 次才能使逆序对数减少到 0，即变成一个有序序列。反过来，如果一个序列最少需要交换 k 次才能变成一个有序序列，那么它的逆序对数就是 k。

```c++
#include<iostream>
#include<vector>

using namespace std;
int res=0;
void mergeSubstr(vector<int> &v,int left,int mid,int right)
{
    vector<int>tmp(right-left+1);
    int i=left,j=mid+1,k=0;// i,j为左右子数组第一个元素位置
    while(i<=mid&&j<=right)
    {
        if(v[j]<v[i])
        {
            res+=mid-i+1; // 找到的一个比v[j]大数字，则前面全是构成逆序数，因为左右子数组必然有序
            tmp[k++]=v[j++];
        }
        else
        {
            tmp[k++]=v[i++];
        }
    }
    while(i <= mid)
    {
        tmp[k++]=v[i++];
    }
    while(j<=right)
    {
        tmp[k++]=v[j++];
    }
    for(int i=left; i<=right; i++)
    {
        v[i]=tmp[i-left];
    }
}
void numsReversal(vector<int>&v,int left,int right)
{
    if(left>=right)
        return;
    int mid=left+(right - left)/2;
    numsReversal(v,left,mid);
    numsReversal(v,mid+1,right);
    mergeSubstr(v,left,mid,right);
}

```



## 最大公共子数组的和



<img src="D:\好康的\image-20230102223749685.png" alt="image-20230102223749685" style="zoom: 50%;" />

<img src="D:\好康的\image-20230102223702189.png" alt="image-20230102223702189" style="zoom: 50%;" />



```c++
int CrossMaxSub(int a[],int left,int mid,int right) // 计算跨越中点的最大子数组
{
    // 初始化leftsum和rightsum为最小值，这样可以保证leftsum和rightsum一定会被赋值，否则可能出现leftsum和rightsum没有被赋值的情况
    int leftsum=-INT64_MAX,left_i,rightsum=-INT64_MAX,right_j,sum=0;

    // 从中点向左遍历，找到最大的子数组
    int i=mid,j=mid+1;
    while (i>=left)
    {
        sum+=a[i--];
        if(sum>leftsum)
            leftsum=sum;
    }
    sum=0; // 重置sum
    while (j<=right)
    {
        sum+=a[j++];
        if(sum>rightsum)
            rightsum=sum;
    }
    return leftsum+rightsum; // 返回跨越中点的最大连续子数组的和
}
int MaxSubSum(int a[],int left,int right)
{
    if(left == right)
        return a[left];
    int mid=(left+right)/2;
    int s1=MaxSubSum(a,left,mid); // 分割左子数组
    int s2= MaxSubSum(a,mid+1,right);
    int s3= CrossMaxSub(a,left,mid,right);
    return max(max(s1,s2),s3);
}
```



## 快速排序

```c++
void quickSort(int arr[], int left, int right)
{
    if (left >= right)
        return;
    int i = left;
    int j = right;
    // 随机选取一个数作为基准数
    int key = left;
    while (i < j)
    {
        while (i < j && arr[j] >= arr[key]) // 当j位置在基准数的位置时循环结束
            j--;
        while (i < j && arr[i] < arr[key])
            i++;
        if (i < j) // 交换左侧大于基准数的数和右侧小于基准数的数，最后一次交换时让i在基准数的位置
            swap(arr[i], arr[j]); // 交换左侧大于基准数的数和右侧小于基准数的数
    }
    quickSort(arr, left, i-1);
    quickSort(arr, i+1, right);
}
```

### 总结

这题的基准不再是等长二分，而是根据某个基准数来进行划分。

$<=和<$ 的不正确混用很可能会导致死循环，主要判断依据还是临界情况。

时间复杂度为 $O（nlogn）$

最坏的情况下  $O（n^{2}）$







#动态规划

>==记忆已经计算的值避免重复计算==
>
>`分解子问题，确定状态转移`

### 0-1背包问题

思想就是对于一个物品**选择带来的价值以及剩余价值之和**与**不选择带来的剩余价值进行比较**

<img src="../好康的/image-20230103153746427.png" alt="image-20230103153746427" style="zoom:50%;" />

<img src="../好康的/image-20230103153947703.png" alt="image-20230103153947703" style="zoom:50%;" />

###$dp[i][w]=max\{dp[i-1][w-v_{i}]+p_{i},dp[i-1][w]\},其中i代表商品编号，w表示当前剩余重量。$

###$dp[i-1][w-v_{i}]+p_{i}表示选择该商品带来的收益，dp[i-1][w]表示不选，故与上一个商品的选择保持一致$



如果采用递归树法时间复杂的为 $O(2^{n})$

1. 第一种优化方法---带备忘录的**自顶向下**求解法

   重复子问题重复调用。

   <img src="../好康的/image-20230103155455504.png" alt="image-20230103155455504" style="zoom:50%;" />

2. 第二种优化方法直接求解 $dp[i][w]$ ---**自底向上**（一到多）求解法

####==从左往右，从上而下求解。==

##$dp[i][w]=max\{dp[i-1][w-v_{i}]+p_{i},dp[i-1][w]\}$

<img src="../好康的/image-20230103155921001.png" alt="image-20230103155921001" style="zoom:50%;" />

<img src="../好康的/image-20230103155927450.png" alt="image-20230103155927450" style="zoom:50%;" />



###实例



<img src="../好康的/image-20230103160325062.png" alt="image-20230103160325062" style="zoom: 67%;" />



###回溯求解决策过程





<img src="../好康的/image-20230103160534145.png" alt="image-20230103160534145" style="zoom: 67%;" />



### 算法实例

![image-20230103160703500](../好康的/image-20230103160703500.png)



### 伪代码求解表格



![image-20230103160749451](../好康的/image-20230103160749451.png)



###**倒序**求解决策过程

![image-20230103161009832](../好康的/image-20230103161009832.png)





## 总结

### 求解的一般步骤

1. 问题结构分析

![image-20230103161212533](../好康的/image-20230103161212533.png)





2. ==**递推关系建立（重点）**==

   ==最优子结构：如果大规模问题的最优解由小规模问题的最优解组成，就说这个问题存在最优子结构，即属于动态规划求解范畴。==

   ==重叠子问题：如果子问题的求解可以借助其他子问题的结果，就说这个问题的求解存在重叠子问题，即属于动态求解范畴==

   ![image-20230103161655349](../好康的/image-20230103161655349.png)

   

   

   ###子问题独立求解，并不是说子问题一定无关，并且最优解与子问题有关

   ![image-20230103161737779](../好康的/image-20230103161737779.png)

3. **自底向上计算**

   <img src="../好康的/image-20230103161855741.png" alt="image-20230103161855741" style="zoom: 67%;" />

   

4. 回溯（可选）

![image-20230103161912641](../好康的/image-20230103161912641.png)



###动态规划与分而治之算法的区别---子问题的独立性

![image-20230103162103564](../好康的/image-20230103162103564.png)





####问题描述

![image-20230103211210426](../好康的/image-20230103211210426.png)



#### 代码实现

```c++
int v[6]={0,9,10,9,2,24}; // 下标作为商品编号，值作为商品价格
int w[6]={0,4,5,4,3,10}; // 下标作为商品编号，值作为商品重量
int d[6][14]={0}; // d[i][j]表示前i个商品中，重量不超过j的最大价值，d数组的每一列都记录了背包容量为j时的最大价值,这些子问题构成了最终结果
int Rec[6][14]={0}; // 记录最优解，Rec[i][j]=1表示第i个商品被选中，j表示起始背包容量
void MaxValue(int dp[][14],int Rec[][14])
{
    for(int i=1;i<=5;i++) // 遍历商品，即行数
    {
        for(int j=1;j<=13;j++) // 遍历重量，即列数
        {
            if(j>=w[i]) // 判断当前商品是否能放入背包！！！
            {
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
                if(dp[i][j]==dp[i-1][j])
                    Rec[i][j]=0;
                else
                    Rec[i][j]=1;
            }
            else
            {
                dp[i][j]=dp[i-1][j];
                Rec[i][j]=0;
            }
        }
    }
    cout<<dp[5][13]<<endl; // 输出最大价值
    for(int i=5;i>=1;i--) // 逆序输出最优解,即根据最优解逆推最优解过程的每一步
    {
        if(Rec[i][13]==1) // 13表示背包容量
        {
            cout<<i<<" ";
        }
    }
}
```







## 最大公共子序列问题

![image-20230110235109706](../好康的/image-20230110235109706.png)



==重点==

 

==例外情况：最后存在多个相同的元素但是只有少于个数的元素构成了最大子序列，对结果求解无影响==

<img src="../好康的/image-20230110235453840.png" alt="image-20230110235453840" style="zoom: 50%;" />





```c++
void MaxSub(string s1,string s2)
{
    int dp[s1.size()+1][s2.size()+1],i,j; // dp[i][j]表示s1的前i个字符和s2的前j个字符的最长公共子序列的长度
    int rec[s1.size()+1][s2.size()+1]; // 记录最长公共子序列的路径，0代表左上，1代表上，2代表左
    for(i = 0; i <= s1.size();i++) // <=不要写成<
    {
        dp[i][0]=0; // s2为空串的情况即j=0
    }
    for (i = 0; i <= s2.size(); i++)
    {
        dp[0][i]=0;
    }
    for(i=1;i<=s1.size();i++) // i从1开始，因为如果不空，子串长度至少为1
    {
        for (j = 1; j <=s2.size(); j++)
        {
            if(s1[i-1]==s2[j-1]) // 如果子串的最后一个字符相等说明最长公共子序列可能包含它们(有例外情况但是不影响求解)
            {
                dp[i][j]=dp[i-1][j-1]+1;
                rec[i][j]=0;
            } else // 如果不等，说明最长公共子序列不包含s1的最后一个字符或者s2的最后一个字符
            {
                dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
                if(dp[i][j]==dp[i][j-1])
                    rec[i][j]=2;
                else
                    rec[i][j]=1;
            }
        }
    }
    cout<<dp[s1.size()][s2.size()]; // 输出长度为s1.size()和s2.size()的最长公共子序列的长度
    endl(cout);
    char ch[min(s1.size(),s2.size())+1]; // 存储最长公共子序列
    int top=0;
    for(i=s1.size(),j=s2.size();i>0&&j>0;) // 从后往前遍历
    {
        if(rec[i][j]==0) // 如果是左上，说明最长公共子序列包含s1[i-1]和s2[j-1]
        {
            ch[top++]=s1[i-1]; // 将子序列元素存入ch
            i--;
            j--;
        } else if(rec[i][j]==1) // 如果是上，说明最长公共子序列不包含s1[i-1],但是包含s2[j-1]
        {
            //ch[top++]=s2[i-1]，不要添加这条语句，因为最长公共子序列虽然包含s2[i-1]
            //但是在s1中这个元素出现在i-1之前，所以不需要添加
            i--;
        } else // 如果是左，说明最长公共子序列不包含s2[j-1]
        {
            j--;
        }
    }
    while(top)
    {
        cout<<ch[--top];
    }
}
```



## 总结

1. $dp数组含义: 长度分别为i，j，并且以s1[i-1],s2[j-1]结尾的子序列的最大公共子序列的长度$
2. $当rec[i][j]!=0时，不要添加ch[top++]=s2[i-1]之类的语句，会导致重复$
3. $由于dp数组的含义，循环起始应该为1，结束条件为串的长度，元素比较要写成s1[i-1]==s2[j-1]$，



## 最大公共子串问题

==元素连续问题==





![image-20230111000752443](../好康的/image-20230111000752443.png)



![image-20230111001413896](../好康的/image-20230111001413896.png)





![image-20230111001402011](../好康的/image-20230111001402011.png)





```c++
void MaxSubStr(string s1,string s2)
{
    int dp[s1.size()+1][s2.size()+1],i,j;
    int p,l; // p记录末尾位置，l记录最长长度
    for(i=0;i<=s1.size();i++)
    {
        dp[i][0]=0;
    }
    for(j=0;j<=s2.size();j++)
    {
        dp[0][j]=0;
    }
    for(i=1;i<=s1.size();i++)
    {
        for(j=1;j<=s2.size();j++)
        {
            if(s1[i-1]==s2[j-1])
            {
                dp[i][j]=dp[i-1][j-1]+1;
                if(dp[i][j]>l) // 更新最大长度
                {
                    l=dp[i][j];
                    p=i-1;  // 更新子串的末尾位置，也可以写成i，那么起始位置就要变成p-l
                }
            }
            else
                dp[i][j]=0;
        }
    }
    cout<<s1.substr(p-l+1,l)<<endl; // substr函数返回从p-l开始，长度为l的子串指针
}
```



## 总结

1. $dp数组含义：长度分别为i，j，并且以s1[i-1],s2[j-1]结尾的公共子串的最大长度$
2. $如果s1[i-1]!=s2[j-1],说明不存在以s1[i-1]，s2[j-1]结尾的公共子串，即公共子串长度为0$
3. $如果s1[i-1]==s2[j-1]，说明公共子串必定包含它们，继续考虑i-1和j-1的子串$
4. $追踪数组rec形式并不一定相同，本题使用p,l来进行追踪要优于使用二维数组$

>凡是涉及字符串的动态规划问题可以从以下几个方面思考
>
>1. 通过末尾字符划分子问题
>2. 通过最后一步操作不断划分子问题
>3. 









## 最小编辑距离



1. ==删除s字符串的元素只需要继续考虑i-1字符串==

<img src="../好康的/image-20230111094113517.png" alt="image-20230111094113517" style="zoom:50%;" />





<img src="../好康的/image-20230111094118663.png" alt="image-20230111094118663" style="zoom:50%;" />





2. ==插入之后继续考虑s的前i的字符串和t的前j-1的字符串==

<img src="../好康的/image-20230111094334290.png" alt="image-20230111094334290" style="zoom:50%;" />





<img src="../好康的/image-20230111094342144.png" alt="image-20230111094342144" style="zoom:50%;" />



3. ==如果末尾字符相同就不用替换，操作次数不变，不同操作次数+1==

<img src="../好康的/image-20230111094608449.png" alt="image-20230111094608449" style="zoom:50%;" />





<img src="../好康的/image-20230111094622301.png" alt="image-20230111094622301" style="zoom:50%;" />





<img src="../好康的/image-20230111094656331.png" alt="image-20230111094656331" style="zoom:50%;" />



<img src="../好康的/image-20230111094706136.png" alt="image-20230111094706136" style="zoom:50%;" />



<img src="../好康的/image-20230111094712418.png" alt="image-20230111094712418" style="zoom:50%;" />





```c++
void MinOpNum(string s1,string s2)
{
    int dp[s1.size() + 1][s2.size() + 1], i, j;
    int rec[s1.size() + 1][s2.size() + 1]; // 0表示插入，1表示删除，2表示替换，3表示不变
    for (i = 0; i <= s1.size(); i++)
    {
        dp[i][0] = i;
        rec[i][0] = 1;
    }
    for (j = 0; j <= s2.size(); j++)
    {
        dp[0][j] = j;
        rec[0][j] = 0;
    }
    for (i = 1; i <= s1.size(); i++)
    {
        for (j = 1; j <= s2.size(); j++)
        {
            // 比较插入、删除、替换三种操作的最小值
            dp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + (s1[i - 1] != s2[j - 1]));
            if (dp[i][j] == dp[i - 1][j - 1] + (s1[i - 1] != s2[j - 1]))
            {
                if (s1[i - 1] != s2[j - 1])
                    rec[i][j] = 2; // 替换
                else
                    rec[i][j] = 3; // 不变
            } else if (dp[i][j] == dp[i - 1][j] + 1)
                rec[i][j] = 1;
            else
                rec[i][j] = 0;
        }
    }
    cout << dp[s1.size()][s2.size()] << endl;
    //------------------------------------------------------------- 可选
    string ch[s2.size() + 1]; // 存储最短操作序列
    int top = 0;
    if (!s1.size() || !s2.size())
    {
        if (!s1.size())
        {
            for (i=s2.size() - 1; i >= 0; --i) // 与下面保持一致
                ch[top++] = string("插入")+s2.substr(i, 1);

        } else
        {
            for (i=s1.size() - 1; i >= 0; --i)
                ch[top++] = string("删除")+s1.substr(i, 1);
        }
    }
    else
    {
        for (i = s1.size(), j = s2.size(); i > 0 && j > 0;)
        {
            if (rec[i][j] == 3)
            {
                ch[top++] = string("不变");
                i--;
                j--;
            } else if (rec[i][j] == 2)
            {
                // substr函数的第二个参数表示截取的长度,返回的是从第一个参数位置开始的长度为第二个参数的字符串
                // 字符串的拼接可以用+号
                // string()可以把char*类型的字符串转换为string类型
                ch[top++] = s1.substr(i - 1, 1) + string("替换").append(s2.substr(j - 1, 1));
                i--;
                j--;
            } else if (rec[i][j] == 1)
            {
                ch[top++] = string("删除") + s1.substr(i - 1, 1);
                i--;
            } else
            {
                ch[top++] = string("插入") + s2.substr(j - 1, 1);
                j--;
            }
        }
    }
    while(top>0)
    {
        cout<<ch[--top]<<endl;
    }
    //------------------------------------------------------------
}
```

## 总结

1. $dp[i][j]数组含义是处理长度为i，j并且以s1[i-1],s2[j-1]结尾的子串的最小编辑距离$
2. $与前两个问题不同的是我们的递推式是三个并列的，即均可选，但不同的选择会导致问题结果改变$



## 大总结

1. $对于字符串的算法，我们一般都是从一般到复杂，观察大规模问题是否与小规模问题有关$

   $例如最大公共子序问题，长度为5的最大公共子序列显然由长度为4的最大公共子序列构成，即子问题的最优解影响整体的最优解$

2. $我们考虑问题一般是自顶向下，但计算确是自底向上，例如，考虑长度为5的子串我们就要去观察长度为4的子串$

3. $dp数组的初始化至关重要，这与数组含义有关$





---



##乘积最大子数组——双状态

```
class Solution {
public:
    int maxProduct(vector<int>& nums)
    {
        int dp[nums.size()],dp2[nums.size()],maxnum; // 一个记录最大状态一个记录最小状态   
        dp2[0]=dp[0]=maxnum=nums[0];
        for(int i=1;i<=nums.size()-1;i++)
        {
            dp[i]=max(dp2[i-1]*nums[i],max(dp[i-1]*nums[i],nums[i]));
            dp2[i]=min(dp[i-1]*nums[i],min(dp2[i-1]*nums[i],nums[i]));
            if(maxnum<dp[i])
                maxnum=dp[i];
        }
         return maxnum;
    }
};

class Solution {
public:
    int maxProduct(vector<int>& nums) 
    {
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            int mx = maxF, mn = minF;
            maxF = max(mx * nums[i], max(nums[i], mn * nums[i]));
            minF = min(mn * nums[i], min(nums[i], mx * nums[i]));
            ans = max(maxF, ans);
        }
        return ans;
    }
};

```



## 分割等和子集

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums)
    {
        int sum=0,target;
        for(auto i:nums)
            sum+=i;
        if(sum&1||sum<2)
            return false;
            target=sum>>1;
        if(*max_element(nums.begin(),nums.end())>target)
            return false;
        // 初始化应该都不满足条件。
            vector<vector<int>> dp(nums.size(), vector<int>(target + 1,false));
            for(int i=0;i<nums.size();i++)
            {
                dp[i][0]=true; // 当剩余容量为0时，都可选
            }
            dp[0][nums[0]]=true;//当只有一个元素时
            for(int i=1;i<nums.size();i++)
            {
                for(int j=1;j<=target;j++)
                {
                    if(nums[i]<=j)
                    {
                        dp[i][j]=dp[i-1][j-nums[i]]||dp[i-1][j]; // 如果上一行已经满足了容量为j的条件或者满足了容量为j-nums[i]的条件，那么这时候一定可以满足
                    }
                    else
                    {
                        dp[i][j]=dp[i-1][j];
                    }
                }
            }
            return dp[nums.size()-1][target];
    }
};
```







## 总结

动态规划不一定只有一种状态，也可能有多种状态，并且状态之间相互联系。





















##算法小题



### 最大子数组和

动态规划求解

```
int maxSubArray(vector<int>& nums)
    {
        int dp[nums.size()],maxnum;// 表示以i为结尾的最大子序和
        maxnum=dp[0] = nums[0];
        for(int i=1;i<nums.size();i++)
        {
            dp[i] = max(dp[i-1]+nums[i],nums[i]); // 比较前面子数组带来的效益+本身 是否大于本身
            if(dp[i]>maxnum)
                maxnum=dp[i];
        }
        return maxnum;
    }
```













## 区间动态规划问题



## 钢条切割问题

```c++
void maxCutVal(int len,const int p[])
{
    vector<int>dp(len+1);
    vector<int>rec(len+1);
    dp[0]=0;
    rec[0]=0;
    int i,j,temp; //temp保存区间1->i-1的最大值
    for(i=1;i<=len;i++) // 自底向上计算
    {
        temp=p[i]; // 初始化temp为不切割的值
        rec[i]=i; // 初始化rec[i]为不切割,即切割长度为i
        for(j=1;j<=i-1;j++)
        {
            if(temp<p[j]+dp[i-j]) // 比较切割长度为j(规定剩下的长度为i-j，便于计算)和当前最大值
            {
                temp=p[j]+dp[i-j];
                rec[i]=j; // 记录切割长度
            }
        }
        dp[i]=temp; // 保存最大值
    }
    cout<<dp[len];
    while(len>0)
    {
        cout<<" "<<rec[len];
        len-=rec[len];
    }
}
```

## 总结

1. 区间动态规划主要是对区间的枚举，然后记录枚举产生的最大值。
2. 追踪数组$rec[ ]$的回溯也有很大不同，$rec[i]$记录的是长度$i$的钢条最后一次切割值，因为处理之后就要继续处理$i-j$的长度，回溯的方法就是不断减去最后一次切割值并输出





## 矩阵链乘法

```c++
void traceback(int i,int j,const vector<vector<int>>&rec) // 思路就是根据记录的分割点不断回溯
{
    if(i==j)
    {
        cout<<"A"<<i; // 递归出口
        return;
    }
    cout<<"(";//在矩阵链i->rec[i][j]的分割点处加括号
    traceback(i,rec[i][j],rec); // 输出矩阵链i->rec[i][j]的分割点
    cout<<") ("; // 在矩阵链rec[i][j]+1->j的分割点处加括号
    traceback(rec[i][j]+1,j,rec); // 输出矩阵链rec[i][j]+1->j的分割点
    cout<<")";
}
void matrixMult(const vector<int>p)
{
    int len=p.size()-1,temp;
    vector<vector<int>>dp(len,vector<int>(len));// dp是从第i个矩阵到第j个矩阵的乘法
    vector<vector<int>>rec(len,vector<int>(len));
    for(int i=0;i<=len-1;i++)
    {
        dp[i][i]=0;
        rec[i][i]=i;
    }
    for(int l=2;l<=len;l++)
    {
        for(int i=0;i<=len-l;i++)
        {
            int j=i+l-1;
            dp[i][j]=INT_MAX;
            for(int k=i;k<=j-1;k++)
            {
                temp=dp[i][k]+dp[k+1][j]+p[i]*p[k+1]*p[j+1]; // i->k的矩阵链相乘后，剩下的是一个排p[i]*p[k+1]的矩阵，同理，再乘一个p[k+1]*p[j+1]的矩阵
                if(temp<dp[i][j])
                {
                    dp[i][j]=temp;
                    rec[i][j]=k; // 记录分割点,分割点是在第k个矩阵处到第k+1个矩阵处加括号
                }
            }
        }
    }
    cout<<dp[0][len-1]<<endl;
    traceback(0,len-1,rec);
}
```





## 带权活动选择问题

[视频讲解](https://www.bilibili.com/video/BV1TC4y1W7wC?p=37)



```c++
typedef struct
{
    int start;
    int finish;
    int profit;
}act;
int slectEnd(vector<act> &a,int i) // 选取最接近i的活动
{
    int num=0,numend=a[0].finish;
    for (int j = 0; j < i; j++)
    {
        if (a[j].finish<=a[i].start)
        {
            if (a[j].finish>numend)
            {
                numend=a[j].finish;
                num=j;
            }
        }
    }
    return num+1; // 返回活动的下标+1,活动从1开始，下标从0开始
}
void selectActPro(vector<act> & act)
{
    sort(act.begin(), act.end(), [](::act a, ::act b) {return a.finish < b.finish; });
    int n = act.size(),l;
    vector<int> dp(n+1); // dp[i]表示前i个活动的最大收益
    vector<int> pre(n+1); // 记录前驱
    vector<bool> selected(n+1, false);
    dp[0] = 0; // 0个活动的最大收益为0
    pre[1] = 0;
    for(int i = 1; i <= n; i++)
    {
        pre[i] = l=slectEnd(act, i-1); // 选取最接近i的活动
        if (dp[i-1] > dp[l] + act[i-1].profit)
        {
            dp[i] = dp[i-1];
        }
        else
        {
            dp[i] = dp[l] + act[i-1].profit;
            selected[i] = true;
        }
    }
    cout << "最大收益为：" << dp[n] << endl;
    cout << "选择的活动为：" << endl;
    for(int i=n;i>=1;i--)
    {
        if(selected[i])
        {
            cout << act[i-1].start << "-" << act[i-1].finish << " " << act[i-1].profit << endl;
            i=pre[i]; // 选择了活动i，下一次考虑活动i的前驱
        }
    }
}
```

## 总结

1. sort函数第三个参数可以用自己定义的bool类型函数来说明排序的依据，此处用到了lambada表达式
2. 活动选择问题和0-1背包问题唯一的不同就是在选择上。如果选择了活动那么就应该考虑活动的前驱而不是前一个活动，这里的前驱指的是最接近该活动的活动，如果不选则无区别。
3. 回溯也有很大不同，如果发现活动 $i$ 被选择了，下一步考虑的应该是前驱而不是 $i-1$ 。







# 贪心算法





# 滑动窗口

1. 左右边界 $left,right$ 
2. 长度为 $right-left+1$ 的子数组构成窗口
3. 对窗口内容进行判断
4. 右边界无任何条件限制增长(长度限制除外)
5. 左边界循环多次收缩
6. 增长和收缩之后要立刻更新窗口内容



> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        map<char,int> mp,mp2;
        string res="";
        if(s.size()<t.size())
            return res;
        for(int i=0;i<t.size();i++)
        {
            mp[t[i]]++;
        }
        int left,right;
        left=right=0;
        bool flag=true;
        while(right<s.size())
        {
            mp2[s[right]]++; // 更新窗口内容
            //对窗口内容判定
            for(auto it:mp)
            {
                if(it.second>mp2[it.first])
                {
                    flag=false;
                    break;
                }
            }
            if(flag==true)
            {
                // 左边界不在t中的字符 以及窗口内容重复太多的字符可以去除
                while(mp.count(s[left]) ==0||mp2[s[left]]>mp[s[left]]) // 循环收缩
                {
                    mp2[s[left++]]--;
                }
                if(res==""||res.size()>right-left+1)
                    res=s.substr(left,right - left+1);
                mp2[s[left++]]--;// 更新窗口内容
            }
            flag = true;
            right++; 
        }
        return res;
    }
};
```

